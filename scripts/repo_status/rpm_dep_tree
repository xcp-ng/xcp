#! /usr/bin/env python3

import argparse
import logging
import re
import sys
import tempfile

import repoquery

ARCH = "x86_64"
SHOW_BOUNDARY = False

# Tell if package is pristine upstream, or part of well-kown list of
# packages we want to consider as "upstream" rather than forks
def is_upstream(rpmname: str) -> bool:
    if repoquery.is_pristine_upstream(rpmname):
        return True
    m = re.match(repoquery.RPM_NVR_SPLIT_REGEX, rpmname)
    assert m, f"{rpmname!r} does not match {repoquery.RPM_NVR_SPLIT_REGEX!r}"
    return m.group(1) in ['systemd', 'util-linux', 'ncurses',
                          # 'xapi',
                          'devtoolset-11-gcc', 'devtoolset-11-binutils']

def main() -> int:

    parser = argparse.ArgumentParser(description="Generate a graph of a package dependencies")
    parser.add_argument('version', help='XCP-ng version to query (8.2, 8.3, 9.0, â€¦)')
    parser.add_argument('srpm', help='Source rpm to query')
    parser.add_argument('-v', '--verbose', action='count', default=0)
    args = parser.parse_args()

    loglevel = {0: logging.WARNING, 1: logging.INFO, 2: logging.DEBUG}.get(args.verbose, logging.DEBUG)
    logging.basicConfig(format='[%(levelname)s] %(message)s', level=loglevel)

    with (tempfile.NamedTemporaryFile() as dnfconf,
          tempfile.TemporaryDirectory() as yumrepod,
          open(f"{args.srpm}-{args.version}.dot", "w") as dotfile):

        repoquery.setup_xcpng_yum_repos(yum_repo_d=yumrepod,
                                        sections=['base', 'updates'],
                                        bin_arch=ARCH,
                                        version=args.version)
        repoquery.dnf_setup(dnf_conf=dnfconf.name, yum_repo_d=yumrepod)

        repoquery.fill_srpm_binrpms_cache()
        # print([x for x in sorted(SRPM_BINRPMS_CACHE.keys()) if x.startswith("openssl-")])
        # return 0

        print("digraph packages {", file=dotfile)
        srpms_seen: set[str] = set()
        new_srpms = {repoquery.srpm_nevr(args.srpm)}
        while new_srpms:
            next_srpms = set()  # preparing next round's new_srpms
            logging.info("seen: %s, new: %s", len(srpms_seen), len(new_srpms))
            logging.debug(" new: %s", new_srpms)
            for srpm in new_srpms:
                # draw source packages themselves
                if is_upstream(srpm):
                    if SHOW_BOUNDARY:
                        print(f'"{srpm}" [color=grey];', file=dotfile)
                    logging.debug("skipping upstream %s", srpm)
                    continue # we don't rebuild upstream rpms
                elif ".xcpng8.3.":
                    print(f'"{srpm}";', file=dotfile)
                else:
                    print(f'"{srpm}" [color=red];', file=dotfile)

                # build reqs
                breqs = {repoquery.rpm_source_package(breq)
                         for breq in repoquery.srpm_requires(srpm)}
                logging.debug("%s req sources: %s", len(breqs), breqs)

                # reqs of binary rpms produced
                reqs = set()
                for binrpm in repoquery.srpm_binrpms(srpm):
                    reqs.update({repoquery.rpm_source_package(req)
                                 for req in repoquery.rpm_requires(binrpm)})

                # draw breqs, plain
                for breq in breqs:
                    if (not SHOW_BOUNDARY) and is_upstream(breq):
                        continue
                    print(f'"{srpm}" -> "{breq}";', file=dotfile)
                # draw additional runtime reqs, dotted
                for req in reqs.difference(breqs):
                    if (not SHOW_BOUNDARY) and is_upstream(req):
                        continue
                    if srpm == req:
                        continue # dependency between RPMs of this SRPM
                    print(f'"{srpm}" -> "{req}" [style=dotted];', file=dotfile)

                # accumulate
                srpms_seen.update(new_srpms)
                next_srpms.update(breqs.difference(srpms_seen))
                next_srpms.update(reqs.difference(srpms_seen))

            new_srpms = next_srpms

        print("}", file=dotfile)
        return 0

if __name__ == "__main__":
    sys.exit(main())
